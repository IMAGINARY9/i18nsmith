import crypto from 'crypto';
import path from 'path';
import os from 'os';
import type { I18nConfig } from './config.js';
import { packageVersion } from './version.js';
import { VueParser } from './parsers/vue-parser.js';
import { TypeScriptParser } from './parsers/typescript-parser.js';

/**
 * Import build-time signature if available.
 * This file is always generated by prebuild.mjs before compilation, so a
 * static import is safe and avoids top-level await (which is incompatible
 * with CJS bundles produced by esbuild).
 */
import { BUILD_TIME_PARSER_SIGNATURE as _BUILD_TIME_PARSER_SIGNATURE } from './parser-signature.js';

const BUILD_TIME_SIGNATURE: string | undefined = _BUILD_TIME_PARSER_SIGNATURE;

export function getToolVersion(): string {
  return packageVersion ?? '0.0.0';
}

export function hashConfig(config: I18nConfig): string {
  const serialized = stableStringify(config);
  return crypto.createHash('sha256').update(serialized).digest('hex');
}

/**
 * Compute a stable signature representing the current implementation of the
 * built-in parsers used for reference extraction. This allows caches to be
 * invalidated automatically when parser logic changes (without a manual
 * CACHE_VERSION bump).
 * 
 * Prefers build-time signature (zero runtime overhead) with fallback to
 * runtime introspection in development mode.
 */
export function getParsersSignature(): string {
  // Use build-time signature if available (production builds)
  if (BUILD_TIME_SIGNATURE) {
    return BUILD_TIME_SIGNATURE;
  }
  
  // Fall back to runtime introspection (development mode)
  return computeRuntimeParserSignature();
}

/**
 * Compute parser signature at runtime via reflection.
 * Used as fallback when build-time signature is not available.
 */
function computeRuntimeParserSignature(): string {
  const parts: string[] = [];
  try {
    // Vue parser important methods (cast prototype to any so TypeScript's
    // access modifiers don't block our runtime introspection).
    const vproto = (VueParser as unknown as { prototype: Record<string, unknown> }).prototype;
    if (vproto) {
      for (const name of ['walkVueAST', 'isTranslationCall', 'extractKeyFromVueCall']) {
  const fn = vproto[name] as ((...args: unknown[]) => unknown) | undefined;
        if (typeof fn === 'function') parts.push(fn.toString());
      }
    }
  } catch (e) {
    // ignore
  }

  try {
    const tproto = (TypeScriptParser as unknown as { prototype: Record<string, unknown> }).prototype;
    if (tproto) {
      for (const name of ['extractKeyFromCall', 'extractReferencesFromFile']) {
  const fn = tproto[name] as ((...args: unknown[]) => unknown) | undefined;
        if (typeof fn === 'function') parts.push(fn.toString());
      }
    }
  } catch (e) {
    // ignore
  }

  const combined = parts.join('\n');
  return crypto.createHash('sha256').update(combined).digest('hex');
}

/**
 * Compute cache version number based on schema version and parser signature.
 * This eliminates the need for manual CACHE_VERSION bumps when parser code changes.
 * 
 * Schema version should only be incremented when the cache structure itself changes
 * (new required fields, removed fields, type changes, etc.).
 * 
 * Parser signature automatically tracks parser implementation changes, so cache
 * invalidates when parser behavior changes without manual intervention.
 * 
 * @param parserSignature - SHA-256 hash of parser implementations
 * @param schemaVersion - Version of the cache structure (default: 1)
 * @returns Computed cache version number
 */
export function computeCacheVersion(
  parserSignature: string,
  schemaVersion: number = 1
): number {
  // Use first 8 hex chars of parser signature as numeric component
  // This gives us 4 billion possible values (16^8 / 2)
  const signaturePrefix = parseInt(parserSignature.substring(0, 8), 16);
  
  // Schema version in millions place, signature in lower places
  // Example: schema=1, sig=0x12345678 -> 1000000 + (0x12345678 % 1000000)
  return schemaVersion * 1000000 + (signaturePrefix % 1000000);
}

/**
 * Detect if code is running in a test environment.
 * Used to provide isolated cache paths for tests.
 */
export function isTestEnvironment(): boolean {
  return (
    process.env.NODE_ENV === 'test' ||
    process.env.VITEST === 'true' ||
    process.env.JEST_WORKER_ID !== undefined ||
    // Vitest/Jest set global test functions
    typeof (globalThis as Record<string, unknown>).it === 'function' ||
    typeof (globalThis as Record<string, unknown>).describe === 'function'
  );
}

/**
 * Get the appropriate cache directory path for the given cache type.
 * In test environments, returns isolated temp directories per process.
 * In production, returns standard cache locations.
 * 
 * @param workspaceRoot - Root directory of the workspace
 * @param cacheType - Type of cache ('extractor' or 'sync')
 * @returns Absolute path to cache directory
 */
export function getCacheDir(
  workspaceRoot: string,
  cacheType: 'extractor' | 'sync'
): string {
  if (isTestEnvironment()) {
    // Use process-isolated temp cache in tests for perfect isolation
    const testId = process.pid;
    return path.join(
      os.tmpdir(),
      'i18nsmith-test-cache',
      String(testId),
      cacheType
    );
  }

  // Production cache paths
  if (cacheType === 'extractor') {
    return path.join(workspaceRoot, 'node_modules', '.cache', 'i18nsmith');
  }
  return path.join(workspaceRoot, '.i18nsmith', 'cache');
}

/**
 * Get the full cache file path for the given cache type.
 * 
 * @param workspaceRoot - Root directory of the workspace
 * @param cacheType - Type of cache ('extractor' or 'sync')
 * @returns Absolute path to cache file
 */
export function getCachePath(
  workspaceRoot: string,
  cacheType: 'extractor' | 'sync'
): string {
  const cacheDir = getCacheDir(workspaceRoot, cacheType);
  return path.join(cacheDir, cacheType === 'extractor' ? 'references.json' : 'sync-references.json');
}

/**
 * Clean up test cache directory for the current process.
 * Should be called in afterAll() or afterEach() hooks in tests.
 * Safe to call in production (no-op).
 */
export async function cleanupTestCache(): Promise<void> {
  if (!isTestEnvironment()) {
    return; // No-op in production
  }

  const { rm } = await import('fs/promises');
  const testCacheDir = path.join(os.tmpdir(), 'i18nsmith-test-cache', String(process.pid));
  
  try {
    await rm(testCacheDir, { recursive: true, force: true });
  } catch {
    // Ignore errors (cache might not exist)
  }
}

function stableStringify(value: unknown): string {
  if (value === null || value === undefined) {
    return JSON.stringify(value);
  }
  if (typeof value !== 'object') {
    return JSON.stringify(value);
  }
  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(',')}]`;
  }
  const entries = Object.entries(value as Record<string, unknown>)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, val]) => `${JSON.stringify(key)}:${stableStringify(val)}`);
  return `{${entries.join(',')}}`;
}
