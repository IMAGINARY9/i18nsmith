#!/usr/bin/env node
import { readFileSync, writeFileSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { createHash } from 'crypto';

const __dirname = dirname(fileURLToPath(import.meta.url));
const packageJsonPath = join(__dirname, 'package.json');
const versionTsPath = join(__dirname, 'src', 'version.ts');
const parserSignatureTsPath = join(__dirname, 'src', 'parser-signature.ts');

const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
const version = packageJson.version || '0.0.0';

// Generate version.ts
const versionContent = `// Auto-generated by prebuild.mjs - do not edit manually
export const packageVersion = '${version}';
`;

writeFileSync(versionTsPath, versionContent);
console.log('✓ Generated version.ts with package version:', version);

// Generate parser signature at build time
function computeParserSignature() {
  const vuePath = join(__dirname, 'src', 'parsers', 'vue-parser.ts');
  const tsPath = join(__dirname, 'src', 'parsers', 'typescript-parser.ts');
  
  try {
    const vueSource = readFileSync(vuePath, 'utf8');
    const tsSource = readFileSync(tsPath, 'utf8');
    
    const combined = vueSource + '\n' + tsSource;
    return createHash('sha256').update(combined).digest('hex');
  } catch (error) {
    console.warn('Warning: Could not read parser files, using fallback signature');
    return 'fallback-signature-' + Date.now();
  }
}

const parserSignature = computeParserSignature();
const parserSignatureContent = `// Auto-generated by prebuild.mjs - DO NOT EDIT
// This file contains a hash of the parser implementations at build time.
// It's used for automatic cache invalidation when parser code changes.
export const BUILD_TIME_PARSER_SIGNATURE = '${parserSignature}';
`;

writeFileSync(parserSignatureTsPath, parserSignatureContent);
console.log('✓ Generated parser-signature.ts:', parserSignature.substring(0, 16) + '...');
